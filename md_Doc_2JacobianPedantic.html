<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QuaternionICP: Ray-Projection Residual with Incidence Weighting w(c)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">QuaternionICP
   </div>
   <div id="projectbrief">Multi-view point cloud registration using ray-projected ICP</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_Doc_2JacobianPedantic.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Ray-Projection Residual with Incidence Weighting w(c)</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md30"></a></p>
<h1><a class="anchor" id="autotoc_md31"></a>
Correct Jacobians (including dw/dc) for SE(3) right-multiplication</h1>
<p>This document gives the correct analytic Jacobians for the ray-projection point-to-plane residual with incidence-based weighting, matching your GeometryWeighting struct.</p>
<p>It covers:</p><ul>
<li>residual definition</li>
<li>SE(3) right-multiplication Jacobians (local increments)</li>
<li>how to include weight w(c) and its derivative dw/dc</li>
<li>explicit formulas for your supported weight modes: Abs : w = |c| SqrtAbs : w = sqrt(|c|) with clamping and gating (tau)</li>
</ul>
<p>This document does NOT discuss any simplified Jacobians.</p>
<hr  />
 <h1><a class="anchor" id="autotoc_md33"></a>
1) Definitions</h1>
<p>We define a scalar residual r(T) of the ray-projection form:</p>
<p>r = w(c) * ( a / c )</p>
<p>where: a = n^T ( x - q ) (meters) c = n^T d (unitless) n is the (fixed) surface normal in the evaluation frame q is the (fixed) hit point in the evaluation frame</p>
<p>Forward case (source -&gt; target frame evaluation): x = R * p + t d = R * d0</p>
<p>Here: p is source point in source-local coordinates d0 is the canonical ray direction in source-local (e.g. (0,0,-1)) R,t are the pose mapping source -&gt; target x,d are expressed in target frame</p>
<p>Note: you may also use the same formulas for backward residuals by changing the expressions for x and d (see Section 6).</p>
<p>We will derive dr/ddelta for SE(3) right-multiplication increments delta.</p>
<hr  />
 <h1><a class="anchor" id="autotoc_md35"></a>
2) GeometryWeighting: gating, clamping, and modes</h1>
<p>Let tau in (0,1] be the gating/clamping parameter.</p>
<p>Given c = n^T d, define:</p>
<p>ac_raw = abs(c)</p>
<p>Gating: if enable_gate and ac_raw &lt; tau: w = 0 and we treat the correspondence as rejected</p>
<p>Weight enable: if not enable_weight: w = 1</p>
<p>Otherwise clamp: ac = clamp(ac_raw, tau, 1) (i.e. ac = max(tau, min(1, ac_raw)))</p>
<p>Then weight modes: Abs : w = ac SqrtAbs : w = sqrt(ac)</p>
<p>Important: If gating is enabled and ac_raw &lt; tau, you typically want to skip the residual entirely (preferred), or set residual and Jacobians to zero. In that gated region, w is effectively constant zero and dw/dc is treated as 0.</p>
<hr  />
 <h1><a class="anchor" id="autotoc_md37"></a>
3) SE(3) right-multiplication perturbation and basic Jacobians</h1>
<p>Right-multiplication update: T_new = T * Exp(delta) with delta = [ v ; w ] in R^6 v: translation increment in local/body frame w: rotation increment in local/body frame</p>
<p>Forward model: x = R*p + t d = R*d0</p>
<p>Under right-multiplication, first-order variations give:</p>
<p>dx/dv = R dx/dw = - R * [p]_x</p>
<p>dd/dv = 0 dd/dw = - R * [d0]_x</p>
<p>Here [u]_x is the 3x3 skew matrix such that [u]_x * y = u cross y.</p>
<p>Define 1x6 row Jacobians for a and c:</p>
<p>a = n^T (x - q) c = n^T d</p>
<p>So:</p>
<p>da/ddelta = n^T * dx/ddelta = [ n^T R , - n^T R [p]_x ] (1x6)</p>
<p>dc/ddelta = n^T * dd/ddelta = [ 0 , - n^T R [d0]_x ] (1x6)</p>
<p>Key property: dc/dv = 0, so translation affects only a, not c.</p>
<hr  />
 <h1><a class="anchor" id="autotoc_md39"></a>
4) Full derivative of r = w(c) * a/c</h1>
<p>Residual: r = w(c) * (a/c)</p>
<p>Differentiate with respect to any parameter theta (component of delta):</p>
<p>dr/dtheta = d/dtheta [ w(c) * a/c ]</p>
<p>Use product + quotient rules. Let: w = w(c) wp = dw/dc</p>
<p>Then:</p>
<p>dr/dtheta = (w/c) * da/dtheta</p><ul>
<li>a * d/dtheta (w/c)</li>
</ul>
<p>But w/c depends on theta only through c:</p>
<p>d/dtheta (w/c) = (d/dc)(w/c) * dc/dtheta</p>
<p>Compute derivative with respect to c:</p>
<p>d/dc (w/c) = (wp * c - w) / c^2</p>
<p>Therefore the correct Jacobian is:</p>
<p>dr/dtheta = (w/c) * da/dtheta</p><ul>
<li>a * ( (wp*c - w) / c^2 ) * dc/dtheta</li>
</ul>
<p>In vector form (1x6):</p>
<p>dr/ddelta = (w/c) * da/ddelta</p><ul>
<li>a * ( (wp*c - w) / c^2 ) * dc/ddelta</li>
</ul>
<p>Because dc/dv = 0, the second term contributes only to rotation columns.</p>
<hr  />
 <h1><a class="anchor" id="autotoc_md41"></a>
5) Computing w(c) and wp = dw/dc for your modes</h1>
<p>We must handle:</p><ul>
<li>abs(c)</li>
<li>clamp to [tau, 1]</li>
<li>gating at abs(c) &lt; tau (optional)</li>
<li>mode Abs or SqrtAbs</li>
<li>enable_weight flag</li>
</ul>
<p>Let s = sign(c), with sign(0) treated as 0 (but gated/clamped avoids exact 0). For c != 0: d/dc abs(c) = sign(c) = s</p>
<h1><a class="anchor" id="autotoc_md42"></a>
Case A: enable_gate and abs(c) &lt; tau</h1>
<p>Interpretation: correspondence rejected.</p>
<p>Recommended behavior:</p><ul>
<li>skip adding residual block, OR</li>
<li>set r = 0 and dr/ddelta = 0</li>
</ul>
<p>If you do the latter: w = 0 wp = 0 r = 0 dr/ddelta = 0</p>
<h1><a class="anchor" id="autotoc_md43"></a>
Case B: not enable_weight</h1>
<p>Then weight is constant: w = 1 wp = 0</p>
<p>So Jacobian reduces to: dr/ddelta = (1/c) * da/ddelta + a * ( (0*c - 1)/c^2 ) * dc/ddelta = (1/c) * da/ddelta - (a/c^2) * dc/ddelta</p>
<p>This is the "no incidence weighting" but still fully consistent derivative (including the denominator derivative of a/c).</p>
<h1><a class="anchor" id="autotoc_md44"></a>
Case C: enable_weight and not gated</h1>
<p>Define: ac_raw = abs(c) ac = clamp(ac_raw, tau, 1)</p>
<p>Clamping effect on wp:</p><ul>
<li>If ac_raw is strictly inside (tau, 1), then ac = abs(c) and derivative passes through.</li>
<li>If clamped at tau or 1, then ac is constant and derivative is 0.</li>
</ul>
<p>So: if ac_raw &lt;= tau: (this is gated out if enable_gate, otherwise clamped) ac = tau, d(ac)/dc = 0 else if ac_raw &gt;= 1: ac = 1, d(ac)/dc = 0 else: ac = abs(c), d(ac)/dc = sign(c) = s</p>
<p>Now per mode:</p>
<p>Mode Abs: w = ac dw/dc = wp = d(ac)/dc</p>
<p>So: wp = 0 when clamped wp = s when unclamped (tau &lt; abs(c) &lt; 1)</p>
<p>Mode SqrtAbs: w = sqrt(ac) dw/dc = wp = (1/(2*sqrt(ac))) * d(ac)/dc</p>
<p>So: wp = 0 when clamped wp = s / (2*sqrt(abs(c))) when unclamped</p>
<p>Note: When unclamped, ac = abs(c). When clamped at tau, use wp=0 (piecewise constant). This matches your implementation semantics (clamp after gating).</p>
<hr  />
 <h1><a class="anchor" id="autotoc_md46"></a>
6) Backward residual (target -&gt; source) under right-multiplication</h1>
<p>If you also evaluate a backward residual in the source frame, you typically use:</p>
<p>x = R^T * (pT - t) (point expressed in source) d = R^T * d0T (ray direction expressed in source)</p>
<p>Then you still use the same weighted form:</p>
<p>r = w(c) * a/c a = n^T (x - q) c = n^T d</p>
<p>But the SE(3) Jacobians for x and d change.</p>
<p>Under right-multiplication, R^T updates as: R_new^T = Exp(-w^) * R^T</p>
<p>First-order variations: d(R^T v)/dw = - [R^T v]_x (3x3 mapping w -&gt; delta) d(R^T v)/dv = 0 (for v being the rotation increment, not translation)</p>
<p>For x = R^T*(pT - t): Let u = (pT - t) x = R^T * u</p>
<p>Then: dx/dv = - R^T (because u depends on t and dt = R*v for right-mult; in practice derive carefully from your chosen parameterization) dx/dw = - [x]_x</p>
<p>For d = R^T*d0T: dd/dv = 0 dd/dw = - [d]_x</p>
<p>Practical recommendation:</p><ul>
<li>If you already have validated formulas from your Python reference, use those.</li>
<li>Then reuse Sections 4 and 5 unchanged (only da/ddelta and dc/ddelta change).</li>
</ul>
<p>The key message:</p><ul>
<li>The weighted derivative structure in Section 4 is universal.</li>
<li>Only da/ddelta and dc/ddelta depend on whether you are forward or backward.</li>
</ul>
<hr  />
 <h1><a class="anchor" id="autotoc_md48"></a>
7) Final Jacobian formula to implement (forward, right-multiplication)</h1>
<p>Given: a, c, w, wp, da/ddelta (1x6), dc/ddelta (1x6)</p>
<p>Compute:</p>
<p>term1 = (w/c) * da/ddelta term2 = a * ((wp*c - w) / (c*c)) * dc/ddelta</p>
<p>J = term1 + term2</p>
<p>Gating:</p><ul>
<li>If enable_gate and abs(c) &lt; tau: set r = 0, J = 0 (or skip residual)</li>
<li>Else compute with clamping rules for w and wp as above.</li>
</ul>
<p>Translation columns:</p><ul>
<li>dc/dv = 0 =&gt; term2 does not affect translation</li>
<li>so translation Jacobian is (w/c) * n^T R</li>
</ul>
<p>Rotation columns:</p><ul>
<li>include both term1 and term2</li>
<li>term2 captures the effect of changing incidence (c) on both the division and the weight</li>
</ul>
<hr  />
 <h1><a class="anchor" id="autotoc_md50"></a>
8) Notes on nondifferentiabilities</h1>
<p>Your weighting uses abs(c) and clamp. Therefore:</p><ul>
<li>w(c) is not differentiable at c = 0</li>
<li>d(abs(c))/dc has a sign discontinuity at c = 0</li>
<li>clamp introduces kinks at abs(c) = tau and abs(c) = 1</li>
</ul>
<p>Your implementation effectively defines a piecewise function. The Jacobian above is therefore piecewise:</p><ul>
<li>use wp = 0 when clamped (piecewise constant region)</li>
<li>use wp = sign(c) (Abs) or sign(c)/(2*sqrt(abs(c))) (SqrtAbs) when unclamped</li>
<li>if gated, set residual/J to 0 (or omit residual)</li>
</ul>
<p>This is standard practice and is consistent with robust gating behavior.</p>
<hr  />
 <h1><a class="anchor" id="autotoc_md52"></a>
9) Summary</h1>
<p>Residual: r = w(c) * a/c</p>
<p>with: a = n^T (R*p + t - q) c = n^T (R*d0)</p>
<p>Right-multiplication Jacobians: da/ddelta = [ n^T R , -n^T R [p]_x ] dc/ddelta = [ 0 , -n^T R [d0]_x ]</p>
<p>Full (fully consistent) derivative including dw/dc: dr/ddelta = (w/c) * da/ddelta + a * ((wp*c - w)/c^2) * dc/ddelta</p>
<p>Weight and derivative (unclamped region tau &lt; abs(c) &lt; 1): Abs : w = abs(c), wp = sign(c) SqrtAbs : w = sqrt(abs(c)),wp = sign(c)/(2*sqrt(abs(c)))</p>
<p>Clamped region (abs(c) &lt;= tau or abs(c) &gt;= 1): wp = 0 (piecewise constant), w = tau-or-1 transformed by mode</p>
<p>Gated region (enable_gate and abs(c) &lt; tau): r = 0, J = 0 (or skip residual entirely) </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
